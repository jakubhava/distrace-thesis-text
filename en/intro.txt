Introduction
Lately, the volume of data applications need to handle is significantly increasing. In order to support this scaling trend, the applications are becoming distributed for reasons of scalability, stability and availability. Not every task may be solved efficiently by distributed applications, however when it comes to big data, the computational requirements may be higher than single physical node can fulfill. Such distributed applications may run on multiple physical or virtual machines in order to achieve the best performance and the ability to process data significantly large. For this, computation clusters are created where the user interacts with the application as it would be running locally and the cluster should handle the distributed computation internally.

However, with growth of distributed applications there is also increasing demand for monitoring and debugging of such applications. Analyzing applications in distributed environment is inherently more complex task comparing to single-node applications where well-known debugging and profiling techniques may be used. All information required for analysis of single-node applications can usually be collected directly from the application itself. In case of distributed applications, it is desired to collect the same information as on single-node applications, and additionally, the shared state between the communicating nodes of the distributed application. For instance, an error may occur on one of the computation nodes in the cluster and over time, more and more nodes can become affected. By collecting the relations between the nodes, the analysis tool may be able to use the collected data to determine where the error initially occurred and how it spread over the time. 

Simple solution comes to mind to address this issue. Monitoring or debugging tools used in the case of single-node applications may be attached per each application node and collect the information from the nodes separately on each other. This solution does not require any additional tools, however the state between the application nodes would not be preserved, unless the monitored application is already designed to share the required information. However, most of the applications is not designed to transfer the information used for analysis of the application itself for several reasons. It may be hard or unwanted to design the application in a way that all the information required for analysis are transferred between communication nodes by default. Also, introduction of a new analysis method could require new metrics to be collected, which would in this case mean recompiling and new deployment of the application.

For these reasons, several new monitoring and debugging tools have been developed. These tools are usually built on the code instrumentation technique, which is used to alter the code of the monitored application at run-time. The introduced code is usually responsible for collection the relevant information used for the application analysis. A significant advantage of this method is that the original application does not have to be changed when a new additional measurement needs to be performed. Usually, such tools use the instrumentation technique to add special information to the code that is later used to build a so-called distributed stack-trace. A stack-trace in single node application represents the call hierarchy of a method at the given moment. Distributed stack-trace is a very similar concept except that the dependencies between different nodes are preserved and can be seen on the collected stack-trace as well. Therefore, distributed stack-traces allow us to see the desired relations between the nodes of a distributed application. Google Dapper and Zipkin are the most significant available monitoring tools and are discussed later in the thesis. 


Project Goals
This thesis introduces Distrace, a monitoring tool with the similar purpose, sharing some of the concepts mentioned above, however the goals of this work are different. The Distrace tool should give the user an universal and high-performance solution to monitoring distributed applications. Main goals of the thesis are to create an open-source generic monitoring library with small footprint on the monitored applications, whilst giving the user the possibility to use high-level programming language to define the custom instrumentation points.

Main requirements for the Distrace tool are:
itemize
	Small Footprint 	 The mentioned cluster monitoring tools can affect the application performance and memory consumption since they perform instrumentation in the same virtual machine as the monitored application. Distrace is required to have minimal footprint on the monitored application. The instrumentation is needed in order to inject special information about spans to the application's code, where spans are structures used to collect the shared state between the application nodes. This information is later used for span collection and associating the relationships between spans.
	Transparency and Universality 	These two requirements are contradictory to each other. The universal monitoring tool for majority of Java applications could collect only basic information shared between these applications and the application-specific observations would be missing. To be able to monitor also specific behavior of some particular application, the developer of this application would be required to manually change the code to also collect specific information to this application. However, this leads to loose of the application-level transparency. 
	
	The introduced tool by this thesis should do some trade-offs between the application-level transparency and the universality of the platform and should try to minimize the the monitored application itself.
	
	Easiness of Use 	The application should use high-level programming language for the instrumentation and specification of additional information to be collected. The users of this tool are supposed to work with Java-based language and should not be required to have deeper knowledge about internal Java Virtual Machine structure.
	Easiness of Deployment 	The deployment complexity of this tool is also a significant aspect. In order for developers and testers to use this tool frequently, its deployment and usage has to be relatively easy. This requirement has two sub-parts. Minimizing the configuration of the monitoring tool to the bare minimum and also minimizing the number of artifacts the users of this tool are required to use.
	Modularity 	The Distrace tool should be designed in a way that some parts of the whole tool may be substituted by user specific modules. For example, the users should be allowed to switch the default user interface to the user interface they prefer without the need of changing the code of the core tool.
itemize

The discussion of different approaches for meeting the requirements above are discussed in the Chapter analysis.

Thesis Outline
The thesis starts with the background in the Chapter chap:background. The purpose of this chapter is to give the reader overview of relevant tools to the thesis such as list of several profiling tools, instrumentation and communication libraries. It also describes the relevant cluster monitoring tools like Google Dapper and Zipkin in more details. The following Chapter analysis contains analysis of the solution and discussion of how specific requirements of the thesis are met. It also mentions the weaknesses of the relevant cluster monitoring tools and describes how the thesis tries to overcome some of the issues. The following Chapter chap:design contains design of the Distrace tool. It starts with the Section design:overview describing overview of the whole tool and depicting the architecture of the whole system. This section is followed by the Section design:use_case demonstrating a simple use case for this tool. Further, the Chapter design:overview contains sections for each important part of the application such as explanation of spans in the Section subsec:spans, the instrumentation server in the Section sec:inst_server, the native agent in the Section native_agent_design and the user interface in the Section sec:zipkin_ui. The next Chapter chap:implementation describes several implementation details in more depth and is followed by the Chapter chap:big_example. The purpose of this chapter is to show a more complex example of how Distrace can be used, in this case on the H2O machine learning platform. The task is to visualize the hierarchy of internal map-reduce calls inside the H2O platform and also to see how long each map and reduce operation last. The last Chapter chap:evaluation mentions the current limitations of the tool, briefly describes some future plans and also gives the overhead measurements of the Distrace tool on the H2O example. 
