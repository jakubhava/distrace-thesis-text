\chapter{Design}
This chapter describes design of the whole platform in details, however implementation details of some specific parts is described in the following chapter. Spans and their format is described first followed by design of native agent and instrumentation server. This chapter ends by describing the selected Zipkin user interface and also JSON format in which the UI accepts the data from the instrumentation server.
\label{chap:design}

\section{Spans}
\label{subsec:spans}
As mentioned briefly in the previous section, spans are used to gather the information about the distributed calls or so called, distributed stacktraces. Spans has several mandatory and optional fields. The mandatory fields are trace id, id and parent id.

Trace id represents one complete distributed call among all interacting nodes on the cluster. The field is attached automatically when a new root span is created. Root span is a first one which is created inside a trace. The root span does not have parent id field set up so the user interface backend can distinguish between regular spans and root spans. Parent if of a span is always id of span from which we received a request to perform some task. The span and its parent span can be located on the same node and on different nodes as well. The first can be useful in cases we would like to capture the communication between different threads on the same node in the same manner as the rest of cluster communication

Span have several additional fields which are set and are used in the Zipkin UI. Each span has also
\begin{itemize}
	\item \textbf{Timestamp} - when the span started
	\item \textbf{Duration} - how long the span lasted
	\item \textbf{Annotations} - annotations which are used to carry additional timing information about spans. For example time when span has been received on the receiver side or the time the span has been processed at the receiver side can be set using the annotations.
	\item \textbf{Binary annotations} - annotations which can be used to carry around application specific details. We can use these annotations to transfer information between communication nodes inside of Spans. For example one node can store number number of bytes sent during the request and the receiver can use this information to calculate overall number of bytes received from this particular node.
\end{itemize}

Each annotation has also endpoint information attached. This consist of:
\begin{itemize}
	\item \textbf{ip} - ip of node on which this event is recorded
	\item \textbf{port} - port on which the service which recorded the span is running
	\item \textbf{service name} - service name can be used to group different traces by names and can be later used to filter such traces in the user interface
\end{itemize}

The following sections contains information about how span are exported for external communication and also how spans are created using \texttt{TraceContext} and \texttt{TraceContextManager} classes.
\subsection{Span Savers}
Spans are internally represented in a JSON format. The thesis contains support for working with JSON data and it is explained in more detail later in the  \hyperref[chap:implementation]{Implementation} chapter. In order to be able to send span data to corresponding user interface or just to save them on disk the spans can be processes using various span savers.

Each saver has to extend from abstract ancestor defining common methods for each span saver. Also in order to be able to use the saver automatically in the code, it has to have a constructor with single \texttt{String} argument accepting saver arguments.

SpanSaver abstract class has 2 abstract methods:
\begin{itemize}
	\item \texttt{saveSpan}. This method is used for saving span. Custom span saver implementaion may save the data on local disk or send over network. The destination is not limited.
	\item \texttt{parseAndSetArgs}. The instrumentation agent accepts also argument which contains arguments for the defined span saver. Each span saver is responsible for parsing the arguments.
\end{itemize}

Spans are saved asynchronously using executor service. The thesis offers 2 default span saver implementation - \texttt{DirectZipkinSaver} and \texttt{JSONDiskSaver}. The first one sends spans to Zipkin 
user interface without storing it on disk. It accepts a single argument which is ip and port of the Zipkin UI service. The second saver is used to save data on disk which can be further collected by some data collector. It accepts single argument which is a directory where spans are saved.

In order to be able to allow the flexibility to add new savers, we have register them in the META-INF directory of the generated JAR file. This ensures that the service loader can find all implementations of the \texttt{SpanSaver} abstract class. The reason why the classes needs to be discovered is explained in the following Native Agent section. To make the developer life easier we use the \textbf{AutoService}  library from \textit{https://github.com/google/auto/tree/master/service}. Instead of manually registering the implemented span savers into META-INF directory, we can annotate them with \texttt{AutoService} annotation with a single argument specifying the abstract parent. The library then takes care of registering the classes automatically so the human error is minimized.

\subsection{Trace Context}
Trace context is class used for storing the information about the current span and also for creating new and closing current spans. Trace context is always attached to a specific thread. This is done in order to allow multiple threads to have different computation state and therefore the platform is able to capture multiple distributed traces at the same time on the same node. Singleton instance of class \texttt{TraceContextManager} is used for attaching the threads to the trace contexts and vice-versa. It has a few methods allowing us to attach trace context to a specific thread and also to get trace context which is attached to a current thread.

Each trace represented by a trace context is uniquely identified by \texttt{Universally unique identifier (UUID)} of type 1 is created. The version 1 of UUID combines 48-bit MAC address of the current device with the current timestamp. This way it is ensured that 2 traces created at the same time on different nodes can't have the same identifier. The identifiers are created using a C++ library called sole (https://github.com/r-lyeh/sole) in the native agent and are made available to the Java code via a published native method.

The trace contact has method \texttt{openNestedSpan} and \texttt{closeCurrentSpan}. The first is used to create a new nested span and set the newly created span as the current one. Nested span is a span which sets its parent id to the current span. A root span is created in case when no current span exists. The second method is used to close the current span. Closing the span triggers the span saver attached to the span and moves one level higher in the span hierarchy to the previous current span.


\section{Native Agent}
mention here the issue with running more JVMs inside one process
\subsection{Structure Overview}
\subsection{Classes}
All custom span savers has to be discovered since they are defined in the instrumentor server JVM, however we need to send these classes to the native
\subsection{Instrumentation}
mention issues with circular dependencies but leave how it is implemented into the next chapter
\subsection{Instrumentation API}
\subsection{Native Agent Arguments}
\subsection{Used JVMTI Callbacks}
\section{Instrumentation Server}
 There is also deployment strategy which allow the programmer to build the server together with the application classes. This has the effect that when a class needs to be instrumented, the agent is not required to send it to the server because server already has the class available. The solu
\subsection{Instrumentation Protocol}
\subsection{Communication Modes}
\subsection{Class Caching}
\subsection{Custom Service Loader}
\subsection{Public interfaces}
\subsection{Extending the Server}
.. instrumentation server can run on the same node or over the network. Instrumentation server can have client code attached or not.
\subsection{Class Loaders}
\subsection{JSON Generation}
\subsection{Deployment Mode}
\label{sec:deploy_mode}
\section{User Interface}
\label{sec:zipkin_ui}
\subsection{Zipkin UI Overview}
\subsection{Zipkin Data Model}
\subsection{Zipkin JSON Format}
\section{Collectors}
Should I mention the collectors ? It may be sufficient to have send data right to zipkin for demonstration purposes
