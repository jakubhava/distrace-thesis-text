\chapter{Design}
This chapter describes design of the whole platform in details, however implementation details of some specific parts is described in the following chapter. Spans and their format is described first followed by design of native agent and instrumentation server. This chapter ends by describing the selected Zipkin user interface and also JSON format in which the UI accepts the data from the instrumentation server.
\label{chap:design}

\section{Spans}
\label{subsec:spans}
As mentioned briefly in the previous section, spans are used to gather the information about the distributed calls or so called, distributed stacktraces. Spans are defined as part of the Instrumentation server but since it's the most important concept in the thesis, we explain them in the separated section. 

Spans has several mandatory and optional fields. The mandatory fields are trace id, id and parent id. Trace id represents one complete distributed call among all interacting nodes on the cluster. The field is attached automatically when a new root span is created. Root span is a first one which is created inside a trace. The root span does not have parent id field set up so the user interface backend can distinguish between regular spans and root spans. Parent if of a span is always id of span from which we received a request to perform some task. The span and its parent span can be located on the same node and on different nodes as well. The first can be useful in cases we would like to capture the communication between different threads on the same node in the same manner as the rest of cluster communication

Span have several additional fields which are set and are used in the Zipkin UI. Each span has also
\begin{itemize}
	\item \textbf{Timestamp} - when the span started
	\item \textbf{Duration} - how long the span lasted
	\item \textbf{Annotations} - annotations which are used to carry additional timing information about spans. For example time when span has been received on the receiver side or the time the span has been processed at the receiver side can be set using the annotations.
	\item \textbf{Binary annotations} - annotations which can be used to carry around application specific details. We can use these annotations to transfer information between communication nodes inside of Spans. For example one node can store number number of bytes sent during the request and the receiver can use this information to calculate overall number of bytes received from this particular node.
\end{itemize}

Each annotation has also endpoint information attached. This consist of:
\begin{itemize}
	\item \textbf{ip} - ip of node on which this event is recorded
	\item \textbf{port} - port on which the service which recorded the span is running
	\item \textbf{service name} - service name can be used to group different traces by names and can be later used to filter such traces in the user interface
\end{itemize}

The following sections contains information about how span are exported for external communication and also how spans are created using \texttt{TraceContext} and \texttt{TraceContextManager} classes.
\subsection{Span Savers}
Spans are internally represented in a JSON format. The thesis contains support for working with JSON data and it is explained in more detail later in the  \hyperref[chap:implementation]{Implementation} chapter. In order to be able to send span data to corresponding user interface or just to save them on disk the spans can be processes using various span savers.

Each saver has to extend from abstract ancestor defining common methods for each span saver. Also in order to be able to use the saver automatically in the code, it has to have a constructor with single \texttt{String} argument accepting saver arguments.

SpanSaver abstract class has 2 abstract methods:
\begin{itemize}
	\item \texttt{saveSpan}. This method is used for saving span. Custom span saver implementaion may save the data on local disk or send over network. The destination is not limited.
	\item \texttt{parseAndSetArgs}. The instrumentation agent accepts also argument which contains arguments for the defined span saver. Each span saver is responsible for parsing the arguments.
\end{itemize}

Spans are saved asynchronously using executor service. The thesis offers 2 default span saver implementation - \texttt{DirectZipkinSaver} and \texttt{JSONDiskSaver}. The first one sends spans to Zipkin 
user interface without storing it on disk. It accepts a single argument which is ip and port of the Zipkin UI service. The second saver is used to save data on disk which can be further collected by some data collector. It accepts single argument which is a directory where spans are saved.

In order to be able to allow the flexibility to add new savers, we have register them in the META-INF directory of the generated JAR file. This ensures that the service loader can find all implementations of the \texttt{SpanSaver} abstract class. The reason why the classes needs to be discovered is explained in the following Native Agent section. To make the developer life easier we use the \textbf{AutoService}  library from \textit{https://github.com/google/auto/tree/master/service}. Instead of manually registering the implemented span savers into META-INF directory, we can annotate them with \texttt{AutoService} annotation with a single argument specifying the abstract parent. The library then takes care of registering the classes automatically so the human error is minimized.

\subsection{Trace Context}
Trace context is class used for storing the information about the current span and also for creating new and closing current spans. Trace context is always attached to a specific thread. This is done in order to allow multiple threads to have different computation state and therefore the platform is able to capture multiple distributed traces at the same time on the same node. Singleton instance of class \texttt{TraceContextManager} is used for attaching the threads to the trace contexts and vice-versa. It has a few methods allowing us to attach trace context to a specific thread and also to get trace context which is attached to a current thread.

Each trace represented by a trace context is uniquely identified by \texttt{Universally unique identifier (UUID)} of type 1 is created. The version 1 of UUID combines 48-bit MAC address of the current device with the current timestamp. This way it is ensured that 2 traces created at the same time on different nodes can't have the same identifier. The identifiers are created using a C++ library called sole (https://github.com/r-lyeh/sole) in the native agent and are made available to the Java code via a published native method.

The trace contact has method \texttt{openNestedSpan} and \texttt{closeCurrentSpan}. The first is used to create a new nested span and set the newly created span as the current one. Nested span is a span which sets its parent id to the current span. A root span is created in case when no current span exists. The second method is used to close the current span. Closing the span triggers the span saver attached to the span and moves one level higher in the span hierarchy to the previous current span.

\section{Native Agent}
The native agent is used for accessing the internal state of the monitored application and to instrument classes to allow us to attach the span and trace identifiers to classes transferred between the application nodes.

The native agent consist of several parts. The most important parts are:
\begin{itemize}
	\item \textbf{Bytecode parsing module}. The classes in this module are used to parse the JVM bytecode in order to discover the classes dependencies for further instrumentation. Bytecode parsing is a technical task described in the following Implementation chapter.
	\item \textbf{InstrumentorAPI}. This class is provides several methods which are used to communicate with the instrumentor JVM. All the queries to the instrumentor are done via instance of this class.
	\item \textbf{AgentCallbacks}. All callbacks used in the native agent are defined in this namespace.
	\item \textbf{AgentArgs}.  This class contains all the logic required for argument parsing.
	\item \textbf{NativeMethodsHelper}. This class is used for registering native methods defined in C++. These methods can be later used from the Java code without worrying of the low-level implementation.
	\item \textbf{Utilities module}. This module contain several utility namespaces. The most important utility namespances are \textbf{AgentUtils} and \textbf{JavaUtils}. The first one is contains method for managing the JVMTI connection together with method for registering the JVMTI callbacks and events. The second one is used for easier work with Java objects in the native code via JNI. 
\end{itemize}

\subsection{Agent Initialization}
The agent is initialized via the same phases as described in the \hyperref[subsec:jvmti_init]{JVMTI Agent Initialization}  section of the \hyperref[chap:background]{Background} chapter. For the thesis purposes, we are interested in the following events: \texttt{VM Init}, \texttt{VM Start}, \texttt{VM Death}, \texttt{Class File load Hook}, \texttt{Class Prepare} and \texttt{Class Load} event. Callbacks are registered for all the mentioned events so we can react to them accordingly in the code.

As part of the initialization process we need to either connect to or start a new instrumentation server. In case the native agent was started in the shared mode of the instrumentation server, the code tries to connect to already existing server. In the local instrumentation mode, the instrumentation server is started as a separated process and the connection is established with the server using the inter process communication. 

The callback registered for the \texttt{VM Init} event is is responsible for loading all additional classes from the instrumentation server as part of the initialization as well. The additional classes are for example \texttt{Span}, \texttt{TraceContext} or custom implementations of \texttt{SpanSaver} abstract class and have to be available to the monitored application since the instrumented code require them as dependencies. The native agent is designed as a code which users should not need to touch and define all application specific code in the instrumentation server extension. Therefore the instrumentation server is asked at the initialization phase for the list of all additional classes and they are sent to the native agent. The agent puts all the received classes on the application's class-path so they are available to the instrumented code.

\subsection{Instrumentation}
Code handling the instrumentation is part of the callback for the \texttt{Class File load Hook} event. The callback has the bytecode for the class which is being loaded on its input and allow as to pass a new instrumented bytecode as the output parameter. The process of instrumentation is described here however the technical details are described in the following chapter.

The process consist of several stages:
\begin{enumerate}
	
	\item Enter the critical section. It can happen that the class file load hook is triggered multiple times and in order to not confuse the instrumentation server, we have to lock before we start instrumentation of a class.
	\item Firstly, we check if the virtual machine is started since we don't need to instrument System classes at this moment.
	\item Attach JNI environment to the current thread. Since the JVMTI and JNI does not have automatic thread management, it's up us to take care of correct threading management.
	\item Discover the class-loader used for loading the class
	\item Parse the name of class being loaded. Even though the callback provides input parameter which should contain the name of loaded class, at some circumstances it can be set to \texttt{NULL} even though the class is correct. Instead of relying on this parameter, we parse the class name from the bytecode ourselves.
	\item Decide weather we should continue with the instrumentation. This check is based on the used class loader and name of the class being loaded. Classes loaded by the \texttt{Boostrap} classloader and in case of Sun JVM, from \texttt{sun.reflect.DelegatingClassloader} are not supposed to be instrumented. 
	The \texttt{Boostrap} is used to load system class and the second mentioned class-loader is used to load synthetic classes and in both cases, it's not desired to instrument classes loaded by these classloaders.
	There are also some ignored classes for which the instrumentation is not desired. Example of these classes are the classes loaded during initialization phase from the instrumentation server and the auxiliary classes generated by the Byte Buddy framework. Auxiliary classes are small helper classes Byte Buddy is using for example for accessing the super class of the currently instrumented class. Therefore we proceed to the instrumentation only If the class is not ignored and not loaded by ignored class loader.
	\item We ask the instrumentation server whether it already contains the loading class or not. If the server does not contain the class, we send the class data to the instrumentation server, parse the class file for all the dependent classes and send all dependent classes to the instrumentatiot. We repeat the dependency scan recurrently until the class does not have any other dependencies or until  we know that the dependency is already available on the server. All dependencies for the currently instrumented class. have to be available on the server in order to perform the instrumentation.
	\item At this stage, the class is already on the instrumentation server and all dependencies for this class as well. Therefore, at this step we can proceed with the instrumentation itself and ask the server for the instrumented class.
	\item Exit the critical section.
\end{enumerate}	
Even though the class is not fully instrumented and the instrumented byte-code is available to the agent, the process is not completely done. The instrumentation library used at the instrumentation sever ( Byte Buddy) is using so called \texttt{Initializer} class to set up the interceptor field in the instrumented classes. It is a static field which references the instance of the class interceptor. This field is automatically set by Byte Buddy framework in most of the cases but since we are instrumenting on different JVM then where the code is actually running, we need to handle this case as well. In order to set this field by corresponding \texttt{Initializer} class we need to have both the initializer class and interceptor available on the agent. The instrumentation server sends the initializer class together with the instance of interceptor during the instrumentation of the class and the agent register the interceptor and initializers with the instrumented class for later since we need to wait for the class to be used for the first time to set the static field to a corresponding interceptor. The initializers are loaded during  \texttt{Class Prepare} event handling. This event is triggered when the class is prepared but no code has been execute so for. 

This callback for this event is also used to register the native methods for the class being loaded. By registering the native method to the class we make it available from Java programming language.

Several technical difficulties had to be dealt with during the development. For example, we need to properly handle cyclic dependencies when instrumenting the class. Also ensuring that the dependencies for the instrumented class are also instrumented in the correct order has been a significant challenge. The different attempts for the solution and the final solution is described in the following chapter since it's highly implementation specific.
\subsection{Instrumentation API}
The Instrumentation API is used to communicate with the instrumentation server. It provides low-level method for sending data in form of byte arrays or strings and the corresponding methods for receiving the data. On top of these method several methods is build to make the communication easier. The most important methods are:
\begin{itemize}
	\item \texttt{sendClassData} method sends byte code to the instrumentation server.
	\item \texttt{isClassOnInstrumentor} method checks weather the bytecode for the given class is already on the instrumentation server or not.
	\item \texttt{instrument} method triggers the instrumentation and returns the instrumented bytecode.
	\item \texttt{loadInitializersFor} method is for loading the initializers for specific class.
	\item \texttt{loadDependencies} method is used to load all dependent classes and upload them on the instrumentation server. The dependency is uploaded only in case it's not already available on the instrumentation server.
	\item \texttt{shouldContinue} method checks weather the class on its input is allowed to be instrumented.
	\item \texttt{loadPrepClasses} method loads all dependent classes in the agent initialization phase.
\end{itemize}

\subsection{Native Agent Arguments}
The native agent accepts several arguments which can be used to affect the agent behavior. In local instrumentation server mode several arguments affect also the sever started from the agent. Available arguments are:
\begin{itemize}
	\item \textbf{instrumentor\_server\_jar} - specifies the path to the instrumentation server jar. It is a mandatory argument in case the instrumentation server is supposed to run per each node of monitored application.
	\item \textbf{instrumentor\_server\_cp} - specifies the classpath for the instrumentation server. It can be used to add application specific classes on the server classpath which has the effect that the monitored application does not have to send the server these classes if they need to be instrumented or if some class to be instrumented depend on them.
	\item \textbf{instrumentor\_main\_class} - specifies the main entry point for the instrumentation server. It is a required argument in case of local instrumentation server mode.
	\item \textbf{connection\_str} - specifies the type of connection between native agent and the instrumentation server. It is a mandatory argument in shared instrumentation server mode in which case the value is in format \texttt{tcp://ip:port} where ip:port is address of the instrumentation server. Otherwise the agent and server communicates via inter-process communication and the argument can be set in format \texttt{ipc://identifier} where identifier specifies the name of pipe in case of Windows and name of the file used for IPC in case of Unix. However this value is set automatically at run-time if not explicitly specified as an argument.
	\item \textbf{log\_dir} - specifies the log directory for the agent and when running in local server mode, specifies the log directory for the server as well.
	\item \textbf{log\_level} - specifies the log level for the agent and when running in local server mode, specifies the log level for the server as well.
	\item \textbf{saver} - specifies the span saver type. The value can be either \texttt{directZipkin(ip:port)} where ip:port is address of the Zipkin UI interface or \texttt{disk(destination)} where destination sets the output directory for the captured spans. Custom span savers are supported as well. In that case the format of the value is a fully qualified name of the span saver with arguments in parenthesis, for example as \texttt{com.span.saver(arguments)}
	\item \textbf{config\_file} - specifies path to a configuration file containing agent configuration. It can contain all arguments mentioned above, each argument per 1 line of the configuration file.
\end{itemize}

\section{Instrumentation Server}
\label{sec:inst_server}
Instrumentation server is responsible the the code instrumentation in separated virtual machine then the application is running. In this section we cover several design aspects of the instrumentation server, leaving the implementation details on the following sections. As already mentioned, the server can run locally on each application node or it can be shared among all the application nodes. The core instrumentation on the server is handled by the Byte Buddy code manipulation framework.

Except from the cached classes, the server does not contain any application state and it just reacts to the agent requests. It can accept four type of requests:
\begin{itemize}
	\item Request for code instrumentation.
	\item Request for storing byte code for a class on the server.
	\item Request for sending dependency classes needed by the agent
	\item Request to check whether the server contains specific class or not.
\end{itemize}
The server interacts in more ways with the agent, however they are just sub-parts of the communication initiated by one of these 4 request types.	

\subsection{Instrumentation}
The instrumentation of the class is triggered by the agent and it's done in 2 stages. The first stage informs the client whether the class is already on the instrumentation server or not. The second stage is the instrumentation itself. The first stage is initiated by the agent who asks the server whether the class is available on the server or not. The server performs this check in 3 phases:
\begin{enumerate}
	\item Check whether the instrumented bytecode for this class is available
	\item If not, check wether the original bytecode for this class is available
	\item If not, check if we can load the class using our context class loader. This handles the cases where the user builds the instrumentation server together with the application classes or adds the application classes on the instrumentation server classpath. 
\end{enumerate}

The server informs the client if it does not have the class, the agent sends the class and the server registers the received byte-code under the class name. The agent therefore does not have to send the class next time since it's already cached on the instrumentation server.
The second stage follows the first stage immediately the first one. If the server already contains the instrumented class in the cache, it sends it right away without instrumenting the class again. If the cache is empty, the class is instrumented and put into the cache.

The code instrumentation is handled by \texttt{CustomAgentBuilder }and \texttt{BaseAgentBuilder} classes.
The instrumentation server expects instance of \texttt{CustomAgentbuilder} on the input of its start method. This is abstract class containing single abstract method \texttt{createAgent(BaseAgentBuilder builder, String pathToGeneratedClasses)} where the builder is wrapper around the Byte Buddy \texttt{AgentBuilder} class which is used to define the class transformers.

The user needs to implement this method and specify on which classes and on which methods the instrumentation should happen. Since Byte Buddy is used for writing transformers and interceptors, please read more about Byte Buddy in the \hyperref[sec:byte_buddy]{Byte Buddy} section. The server provides several helper methods for creating the transformers and interceptors which are less verbose then the standard Byte Buddy approaches.

Each created transformer has to have associated some interceptor which defines the instrumented code. Each interceptor has to implement \texttt{Interceptor}  interface. This is required for the server to be able to discover all interceptors at run-time without the need for changing the internals of the sever. Each implementation of the interceptor needs to register itself in the META-INF directory of the generated jar in a same way as it the span savers mentioned in the previous section. Custom service loader is then used to locate all classes implementing the \texttt{Interceptor} interface.

Even though Byte Buddy takes care about the instrumentation, the \texttt{BaseAgentBuilder} class is internally properly configured so the instrumentation happens exactly as desired. The class implements for 4 byte buddy listeners used for informing us about the instrumentation progress and allow us to react on the process of the instrumentation. The listeners are:
\begin{itemize}
	\item \texttt{onTransformation} listener is called immediately before the class is instrumented. Our implementation of the listener also sends the agent all auxiliary classes required by the instrumented class and the initializers used for setting the static interceptor field on the instrumented class.
	\item \texttt{onIgnored} listener is called when the class is not instrumented. The class is not instrumented when the user does not define any transformer for the specified class.
	\item \texttt{onError} listener is called when some exception occurred during the instrumentation.
	\item \texttt{onComplete} listener is called when instrumentation process completed. It is called after both of \texttt{onTransformation} and \texttt{onIgnored} listeners
\end{itemize}



Byte buddy requires dependencies for the instrumented class to be available. They are needed because the instrumentation framework needs to know signature of all methods in several cases, for example when the method is override in the child class. The dependencies are all the classes specified in the class file such as type of return value, arguments, super class or interfaces. 
By default, Byte Buddy tries to find these dependencies using two classes - \texttt{LocationStrategy} and \texttt{PoolStrategy}. The first class is used to tell Byte Buddy where to look for the raw byte code of dependent classes. The classes are loaded by context class loader by default, but since the classes are received over the network we use our \texttt{InstrumentorClassloader} to handle the class loading. It is a simple class loader which keeps the cache of the classes received from the agent and when a request for instrumentation comes, instead of looking into the class files, it loads the data from the cache in the memory.

However, Byte Buddy internal API does not work with raw byte code for scanning the further dependencies and obtaining the metadata for the classes. It uses classes \texttt{TypeDescription} and \texttt{PoolStrategy} for this purpose. The first class has a constructor accepting the \texttt{Class} class and contains the metadata for the class such as the signature of all methods and fields, list of all interfaces or for example list of constructors. The second one class is used for caching the type descriptions so they are not created every time the class is accessed. 

So in overall, class lookup is done in the following 2 steps:
\begin{enumerate}
	\item Check whether type description for the class is available. If yes, load the description from the cache.
	\item If the type description is not available, load the class using the \newline \texttt{InstrumentorClassloader}, create type description for it and put it on the cache
\end{enumerate}

\subsection{Custom Service Loader}
In order to keep the instrumentation extendable we use concept of service loaders for loading the extensions. This is done for 2 types:
\begin{itemize}
	\item Custom span savers. Each span saver inherits from the abstract class \texttt{SpanSaver}
	\item Custom Interceptors. Each interceptor implements the interface \texttt{Interceptor}
\end{itemize} 
The user can create custom span savers and interceptors by either inheriting the desired class or implementing the required interface and put the name of the class inside the text file in the META-INF directory in the JAR file. The text file has to have the name of the abstract class or the interface the implementation is for. For example, when user creates a new Interceptor called \texttt{x.y.InterceptorA}, the file \texttt{Interceptor} has to \textbf{x.y.InterceptorA}.

Java provides service loader for this purpose. However the standard Java implementation looks up the classes defined as above and automatically creates new instances using the well-known constructors. For the thesis purposes this was unwanted as we need to have the \texttt{Class} object representing the class available. Therefore a custom service loader was created for this purpose. This loader works in very similar way as the standard Java one, but instead of returning the instances of loaded services it just returns loaded service classes. 
\subsection{JSON Generation}
The spans are internally stored as instances of \texttt{JSONValue} class since in order to support the communication with the default Zipkin UI they need to be exported as JSON. JSON is a lightweight format for exchanging data where the syntax is based on Javascript object notation.

The JSON handling is based on the https://github.com/ralfstx/minimal-json library, however we created custom simplified implementation which fits the theses requirements. Also the number of dependencies is lowered by this decision. 

This JSON support is designed using several classes:
\begin{enumerate}
	\item \textbf{JSONValue}. The abstract ancestor of all JSON types. This type defines common methods to all implementation.
	\item \textbf{JSONString}. Class representing the string type.
	\item \textbf{JSONNumber}. Class representing the number type.
	\item \textbf{JSONLiteral}. Class representing the literals \textbf{null}, \textbf{true} and \textbf{false}.
	\item \textbf{JSONArray}. Class representing the JSON arrays. It has support for adding new elements into the array.
	\item \textbf{JSONObject}. Class representing the JSON objects. It has support for adding a new items in the object.
\end{enumerate}

Each \textbf{JSONValue} can be printed as valid JSON string and the printing is driven by a class \texttt{JSONStringBuilder}. This class is also responsible for escaping the characters according to JSON standards. The default printer prints the data without any formatting as one line, however \texttt{JSONPrettyStringBuilder} prints the data in more human-readable format. The second printer is usually used for debugging purposes and the first one for real usage as the size of the data is smaller in this case.

\section{User Interface}
\label{sec:zipkin_ui}
\subsection{Zipkin UI Overview}
\subsection{Zipkin Data Model}
\subsection{Zipkin JSON Format}
