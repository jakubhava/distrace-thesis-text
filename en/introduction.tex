\chapter{Introduction}
The volume of data processed is becoming larger every day. In order to process this data, the application are becoming distributed for reasons of scalability, stability and availability. However reasoning about distributed applications is inherently more complex. In case of single node application we can use standard monitoring or profiling tools which give us data to reason about the application, but in the complex cluster solutions this can't be applied. We could use standard monitoring tools per each node in the cluster however we still could reason only about one particular node and not the whole cluster.

Several monitoring tools for such a problem have been already developed. The most significant one is proprietorial software from Google called Google Dapper and open-sourced tool called Zipkin.

This thesis introduces another monitoring tool for the similar purpose, however it has some different concepts than the tools mentioned above. Google Dapper is build proprietorial and available only for Google applications. In case of Zipkin, the user has to instrument the application itself by introducing the annotation. 

\section{Project Goals}
The project should make some trade-offs between application level transparency and easiness of use. Therefore, we can think of this solution more as a extendable library providing the developer with means how to instrument their specific application in high-level programming language such as Java. All instrumentation specific internals and low-level code is hidden from the user but low-level overhead is still achieved by multiple techniques discussed later. So the user-programmer has to extend the prepared library for their specific application by defining points where instrumentation should take place, but the original application can still remain unaffected.

The project should also be extensible in a way that information from additional low-level system monitoring tools can be attached to the monitored data - such as the memory usage or data allocation. We use  native java agent written in C++ for the instrumentation purposes and the architecture is prepared to combine the monitored data from our tool with the other external tools.  Also, using the native client we achieve low-overhead on the system and can query various interesting information such as number of loaded classes, garbage collection time and so on. 

One of the most important aspects of the introduced tool is the deployment. In order for developers and testers to use this tool, it needs to be really easy to deploy it. This was achieved by limiting the number of artifacts to the bare minimum and therefore when it comes to using the tool, the user has only 2 files - native agent which needs to be attached to monitored application and Instrumentation server written in java which handles the instrumentation for the whole cluster application. Several deployment strategies exist and are discussed later in the \ref{chap:evaluation} chapter.

\section{Thesis outline}
The thesis starts 

