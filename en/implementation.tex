\chapter{Implementation Details}
\label{chap:implementation}
This chapter explains several technical implementation details. It starts with explanation of the byte code parsing and instrumentation at the native agent part of the complete tool. The following section covers relevant parts of the instrumentation server which are the instrumentation together with creation of transformers and estimators. This chapter ends with a brief explanation of how the spans are exported to the Zipkin user interface and also, how the spans can be exported to a custom data format.

\section{Native Agent}
The native agent consists of several interesting technical parts. This section covers the instrumentation itself and also explains considered approaches during the development. The problem of instrumentation server requiring the dependencies for each instrumented class is explained together with the problem of instrumenting the classes with cyclic dependencies. The final solution is explain as well. 

In the following part, the internals of how JVM byte-code is parsed is explained.
\subsection{Instrumentation}
In general, the native agent does not perform the instrumentation but gets byte code for the the required class, sends the byte code to the instrumentation server and applies the instrumented byte code after receiving it from the client. 

The instrumentation server required all dependencies to be available for the currently instrumented class. This means that all other classes mentioned as part of method and field signatures, super classes or interfaces has to be available on the instrumentation server. To achieve this, two solutions have been tried but only the second solution shown to be feasible.

The first and unsuccessful solution was based on the fact that several on class file load hooks may be executed at several time in different threads. When the application loads a class, the class load hook event is triggered for it and its byte code is made available. In this method, the new class file load hook event was artificially enforced via the \texttt{RetransformClasses} method. This method accepts array of classes for which the hook should be re-thrown. In order to continue with the instrumentation of the original class, all dependent classes have to be instrumented in this solution first. This also means that in this approach, the classes with cyclic dependencies are not supported. In order to instrumented such a class, all dependencies have to be instrumented first which is also the class itself.

This solution had also different problem. Since a number of dependencies can be significant, the problem of too many threads being opened at a single time has also appeared. 

The second and currently used solution is based on the fact that the Java class files may be accessed as a resource using the class loader of the class currently being load. Disadvantage of this solution that the developer may override the \texttt{getResourceAsStream} method on the custom class loader and not provide access to he class files. This is a limitation of the thesis. However, when a such event happens, the instrumentation does not end with the exception but first, the attempt to load the class using a different class loader is done. 

In this solution, the instrumentation server is first asked whether the current class should be instrumented based on the server's extensions. If the class is designed to be instrumented, its byte code is send to the instrumentation server (only in case if the byte code for the class is not already available). Then, dependencies are scanned via parsing the raw JVM byte code which is explained in detail in the following section. Dependency loading is recursively called for each new dependent class until the class does not have any other dependencies or if all the dependencies are already uploaded to the instrumentation server. Once all dependencies for a class have been sent to the server, the instrumentation is invoked and the agent waits for the new byte code. 

 Also several helper classes are sent back to the native agent at the stage where the class is checked whether it should be instrumented or not. The classes are auxiliary Byte Buddy classes and also instances of \texttt{LoadedTypeInitializer} class. The initializers are sent as serialized 
instances and therefore their defining class has to be available in the application. This is achieved in the agent initialization phase where several required classes are sent to the application from the server. The instances are saved to a map which maps the initializer name to its serialized representation. This initializer is later using during the class preparation phase to set the static interceptor field of the instrumented class as mentioned in the previous sections.

The auxiliary classes are classes created at run-time during the instrumentation on the server and have to be available on the applications machine as well. This is achieved by loading the byte code for the auxiliary class, saving the the class as a java class file on the disk and making it available by adding the class on the application's class path.

\subsection{Byte Code Parsing}
Byte code parsing is necessary feature of the thesis and is required in order to be able to get the list of dependent classes on a class currently being loaded. No sufficient C++ implementation has not been found and therefore a custom parsing module has been implemented. The parsing module is based on the Apache Commons BCEL Java package and the simplified version but still with the same logic has been rewritten to C++.

The main class used for parsing is \texttt{ClassParser} which contains \texttt{parse} method accepting the byte code of a class and defines also several accessors  for the parsed data such as the super class name and complete reference, list of all implemented interfaces, list of all methods or list of all defined fields and their types.

The byte code starts with the several important parts:
\begin{itemize}
	\item \textbf{Magic id}. Magic id is a first integer stored in each byte code and contains  always 0xCAFEBABE number.
	\item \textbf{Version}. This part contains actually two shorts, where the first short represents minor Java version and the later one represents major Java version.
	\item \textbf{Constant pool}. Constant pool is a table representing class and interface names, field names and also other important constants. It contains mapping from id representing the type to the fully qualified type name.
	\item \textbf{Class Info}. Class information contains the information whether the byte code represents a class or an interface, denotes class name and also super class name.
	\item \textbf{Interfaces}. This part contains the number of interfaces this class implements followed by id of type short of each interface. The interface can be looked up using the class pool.
	\item \textbf{Fields}. This part of the byte code contains the number of fields this class defines together with some additional information for each defined field.
	\item \textbf{Methods}. This part contains the number of defined methods in the byte code together wit additional information per each method such as the number of arguments.
\end{itemize}
More information about class file structure can be found at https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html. 
Each part of the class file mentioned above is parsed separately. For accessing the raw byte code a \texttt{ByteReader} class is used. It contains methods fro reading different types of data from the byte code array. 

Parsing the magic id and both minor and major versions is straightforward as their are just numbers and can be read using the byte reader class directly. Parsing of the constant pool is more complex. For each entry in the constant pool a constant representing the entry is read. The constant can be of several type such as constant representing the Class symbol, String symbol, Method types of Field types for example. Once the Constant pool is parsed, it can be queried for the specific symbol by its id. Class name and super class name, interfaces, fields and methods are read from the constant pool by using their ids.
\section{Span Injection on Instrumentation Server}
This short section explains how additional fields such as the span information are internally attached to the instrumented classes. The trace information is attached to the instrumented class by adding a new synthetic field with name \texttt{\_\_\_\_traceId}. This trace id represents the current trace and is used in the code to obtain reference to a current trace context and also current span.  A new field is created using the Byte Buddy instrumentation builder using the \texttt{defineField} method.
\section{Determine the Current Span Saver}
This section explains how span saver type and also other arguments passed to the native agent are made accessible to the instrumentation saver. The span saver type is defined as part of the native agent and needs to be used at the instrumentation server as well. This is achieved by creating and registering the native method to a class which is defined as part of the instrumentation server.
In span saver case, the abstract class \texttt{cz.cuni.mff.d3s.distrace.storage.SpanSaver} is defined at the instrumentation server and contains also native agent for getting the span saver type. The abstract \texttt{SpanSaver} class is sent to the native agent during the initialization phase. When this class is used for the first time, the native method implementation is bound to the method \texttt{getSpanSaverType} defined in the \texttt{SpanSaver} class. Therefore, even the the classes defined as part of the instrumentation server can use method defined on the native agent with a really small overhead. Actually there may be a performance gain since these methods are written as native methods.



